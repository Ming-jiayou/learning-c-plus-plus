## 计数排序算法

计数排序（Counting Sort）是一种非比较排序算法，适用于待排序元素的值域较小的情况。它的基本思想是通过统计每个元素出现的次数来确定每个元素在排序后的位置。计数排序的时间复杂度为 O(n + k)，其中 n 是待排序元素的个数，k 是待排序元素的值域范围。

### 计数排序的基本步骤：

1. **初始化计数数组**：
   - 创建一个长度为 `k` 的计数数组 `count`，其中 `k` 是待排序元素的最大值加一。
   - 将计数数组 `count` 的所有元素初始化为 0。
2. **统计每个元素的出现次数**：
   - 遍历待排序数组，对于每个元素 `arr[i]`，将 `count[arr[i]]` 的值加一。
3. **累加计数数组**：
   - 遍历计数数组，将每个元素 `count[i]` 更新为 `count[i]` 加上 `count[i-1]` 的值。这样，`count[i]` 表示小于或等于 `i` 的元素的总数。
4. **生成排序结果**：
   - 创建一个与待排序数组长度相同的输出数组 `output`。
   - 从后向前遍历待排序数组，对于每个元素 `arr[i]`，根据 `count[arr[i]]` 确定其在输出数组中的位置，并将 `count[arr[i]]` 减一。
5. **复制结果**：
   - 将输出数组 `output` 复制回原数组 `arr`。

### 计数排序的示例：

假设待排序数组 `arr = [4, 2, 2, 8, 3, 3, 1]`，最大值为 8，因此计数数组的长度为 9（从 0 到 8）。

1. **初始化计数数组**：

   ```
   count = [0, 0, 0, 0, 0, 0, 0, 0, 0]
   ```

2. **统计每个元素的出现次数**：

   ```
   count = [0, 1, 2, 2, 1, 0, 0, 0, 1]
   ```

3. **累加计数数组**：

   ```
   count = [0, 1, 3, 5, 6, 6, 6, 6, 7]
   ```

4. **生成排序结果**：

   ```
   output = [1, 2, 2, 3, 3, 4, 8]
   ```

5. **复制结果**：

   ```
   arr = [1, 2, 2, 3, 3, 4, 8]
   ```

### 计数排序的优缺点：

- **优点**：
  - 时间复杂度为 O(n + k)，在 k 较小的情况下，性能优于基于比较的排序算法（如快速排序、归并排序）。
  - 稳定排序，相同元素的相对顺序在排序后保持不变。
- **缺点**：
  - 需要额外的空间来存储计数数组和输出数组。
  - 当 k 很大时，空间复杂度较高，不适合处理值域范围很大的数据。

计数排序适用于值域范围较小且元素分布较为均匀的情况，例如对整数进行排序。